/* -*- C++ -*-
 *  Authors:
 *    Anna Neiderud (annan@sics.se)
 *    Konstantin Popov <kost@sics.se>
 * 
 *  Contributors:
 * 
 *  Copyright:
 * 
 *  Last change:
 *    $Date$ by $Author$
 *    $Revision$
 * 
 *  This file is part of Mozart, an implementation 
 *  of Oz 3:
 *     http://www.mozart-oz.org
 * 
 *  See the file "LICENSE" or
 *     http://www.mozart-oz.org/LICENSE.html
 *  for information on usage and redistribution 
 *  of this file, and for a DISCLAIMER OF ALL 
 *  WARRANTIES.
 *
 */

#include "base.hh"
#include "dpBase.hh"
#include "dpMarshaler.hh"

#include "byteBuffer.hh"
#include "msgContainer.hh"

#define HandleTerm(AuxPreparation)				\
{								\
  Assert(cont == (void *) 0);					\
  Assert(!checkFlag(MSG_HAS_MARSHALCONT));			\
  DPMarshaler *dpm = transController->getMarshaler();		\
  DPMarshaler *dpmCont;						\
  if (dpm == (DPMarshaler *) 0)					\
    OZ_error("No marshalers");					\
  AuxPreparation;						\
  dpmCont = dpMarshalTerm((OZ_Term) msgFields[i].arg,		\
                          bb, dpm, destination);		\
  if (dpmCont == (DPMarshaler *) 0) {				\
    msgFields[i].ft = FT_NONE;					\
    transController->returnMarshaler(dpm);			\
    continue;		/* negotiated the field; */		\
  } else {							\
    Assert(dpm == dpmCont);					\
    setFlag(MSG_HAS_MARSHALCONT);				\
    msgFields[i].ft = FT_TERMCONT;				\
    this->transController = transController;			\
    cont = (void *) dpmCont;					\
    return;							\
  }								\
}

void
MsgContainer::marshal(ByteBuffer *bb, TransController *transController)
{
  for (int i = MAX_NOF_FIELDS; i--; ) {
    switch(msgFields[i].ft) {
    case FT_NUMBER:
      if (bb->availableSpace() >= MNumberMaxSize) {
	marshalNumber(bb, (int) msgFields[i].arg);
	msgFields[i].ft = FT_NONE;
	continue;		// next field;
      } else {
	setFlag(MSG_HAS_MARSHALCONT); // maybe sets it again;
	return;
      }

    case FT_CREDIT:
      if (bb->availableSpace() >= MNumberMaxSize) {
	marshalNumber(bb, (int) msgFields[i].arg);
	msgFields[i].ft = FT_NONE;
	continue;
      } else {
	setFlag(MSG_HAS_MARSHALCONT);
	return;
      } 

    case FT_FULLTOPTERM:
      HandleTerm(dpm->genFullToplevel());

    case FT_TERM:
      HandleTerm(;);

    case FT_TERMCONT:
      { 
	Assert(checkFlag(MSG_HAS_MARSHALCONT));
	Assert(cont != (void *) 0);
	DPMarshaler *dpm = (DPMarshaler *) cont;
	DPMarshaler *dpmCont;
	//
	dpmCont = dpMarshalContTerm(bb, dpm);
	if (dpmCont == (DPMarshaler *) 0) {
	  msgFields[i].ft = FT_NONE;
	  transController->returnMarshaler(dpm);
	  cont = (void *) 0;	// already returned;
	  continue;		// FINALLY negotiated the field;
	} else {
	  return;		// HAS_MARSHALCONT is still set;
	}
	Assert(0);
      }

    case FT_STRING:
      if (bb->availableSpace() >= MAX_DP_STRING) {
	marshalString(bb, (char*) msgFields[i].arg);
	msgFields[i].ft = FT_NONE;
	continue;
      } else {
	setFlag(MSG_HAS_MARSHALCONT);
	return;
      }
      Assert(0);

    case FT_SITE:
      if (bb->availableSpace() >= MDSiteMaxSize) {
	((DSite*) msgFields[i].arg)->marshalDSite(bb);
	msgFields[i].ft = FT_NONE;
	continue;
      } else {
	setFlag(MSG_HAS_MARSHALCONT);
	return;
      }
      Assert(0);

    case FT_NONE:
      continue;
    }

    // We bail out of the case statement iff we have a suspension,
    // otherwise do 'continue' directly:
    Assert(0);
  }

  // If all elements are done, then it's over:
  clearFlag(MSG_HAS_MARSHALCONT);
}

undefine(`message')
undefine(`argEnc')

define(message,`
       void MsgContainer::put_$1(mcarg($2,$3) mcarg($3,$4) mcarg($4,$5) mcarg($5,$6) mcarg($6,$7)) {
         mt=$1;
         argEnc($2,0)
	 argEnc($3,1)
	 argEnc($4,2)
	 argEnc($5,3)
	 argEnc($6,4)
       }')

define(mcarg,`ifelse($1,Index,Ext_OB_TIndex ind,
                     $1,Term,TaggedRef t,
                     $1,FullTopTerm,TaggedRef t,
		     $1,String,char const *str,
                     $1,Credit,int c,
                     $1,Site,DSite *s1,
	             $1,Site2,DSite *s2,
	             $1,Int,int int1,
	             $1,Int2,int int2)'
              `ifelse($2,`',`',`,')')

define(argEnc,`ifelse($1,Index,msgFields[$2].arg=(void *) ind; msgFields[$2].ft=FT_NUMBER;,
                     $1,Term,msgFields[$2].arg=(void *) t; msgFields[$2].ft=FT_TERM;,
                     $1,FullTopTerm,msgFields[$2].arg=(void *) t; msgFields[$2].ft=FT_FULLTOPTERM;,
		     $1,String,Assert(MAX_DP_STRING>=strlen(str)); msgFields[$2].arg=(void *) str;msgFields[$2].ft=FT_STRING;,
                     $1,Credit,msgFields[$2].arg=(void *) c; msgFields[$2].ft=FT_CREDIT;,
                     $1,Site,msgFields[$2].arg=(void *) s1; msgFields[$2].ft=FT_SITE;,
	             $1,Site2,msgFields[$2].arg=(void *) s2; msgFields[$2].ft=FT_SITE;,
	             $1,Int,msgFields[$2].arg=(void *) int1; msgFields[$2].ft=FT_NUMBER;,
	             $1,Int2,msgFields[$2].arg=(void *) int2; msgFields[$2].ft=FT_NUMBER;,
		     msgFields[$2].ft=FT_NONE;)')

include(EMUDIR/msgFormat.m4)

undefine(`message')
undefine(`mcarg')
undefine(`argEnc')

inline void messageError(MessageType mt, char const *origin)
{
  OZ_error("Malicious message received: %s %s",mess_names[mt],origin);
//  OZ_warning("Malicious message received: %s %s",mess_names[mt],origin);
//  printf("Malicious message received: %s %s\n",mess_names[mt],origin);
}

define(message,`
       case $1:
       msgFields[0].ft=argEnc($2);
       msgFields[1].ft=argEnc($3);
       msgFields[2].ft=argEnc($4);
       msgFields[3].ft=argEnc($5);
       msgFields[4].ft=argEnc($6);
       break;')


define(argEnc,`ifelse($1,Index,FT_NUMBER,
	              $1,Term,FT_TERM,
	              $1,FullTopTerm,FT_FULLTOPTERM,
	              $1,Credit,FT_CREDIT,
	              $1,String,FT_STRING,
                      $1,Site,FT_SITE,
                      $1,Site2,FT_SITE,
		      $1,Int,FT_NUMBER,
		      $1,Int2,FT_NUMBER,
		      FT_NONE)')

void MsgContainer::setMessageType(MessageType mtIn)
{
  mt = mtIn;
  switch (mtIn) {
    include(EMUDIR/msgFormat.m4)
      default:
	PD((TCP_INTERFACE,"unmarshal got unknown `message': %d",mt));
  }
}

Bool
MsgContainer::unmarshal(ByteBuffer *bb, TransController *transController)
{
  // the MSG_HAS_UNMARSHALCONT flag can be set;
  for (int i = MAX_NOF_FIELDS; i--; ) {
    if (msgFields[i].ft != FT_NONE && !bb->canGetInFrame(1)) {
      setFlag(MSG_HAS_UNMARSHALCONT); // maybe sets it again;
      return (TRUE);
    } else {

      switch(msgFields[i].ft) {
      case FT_NUMBER:
	msgFields[i].arg = (void *) unmarshalNumber(bb);
	msgFields[i].ft = FT_NONE;
	continue;		// next field;

      case FT_CREDIT:
        msgFields[i].arg = (void *) unmarshalNumber(bb);
	msgFields[i].ft = FT_NONE;
	continue;

	//
	// There is one single unmarhslaer that understands also full
	// objects (and potentially also other structures with the
	// lazy protocol);
      case FT_FULLTOPTERM:
      case FT_TERM:
	{
	  Assert(cont == (void *) 0);
	  Assert(!checkFlag(MSG_HAS_UNMARSHALCONT));
	  Builder *dpum = transController->getUnmarshaler();
	  if (dpum == (Builder *) 0)
	    OZ_error("No unmarshalers");
	  dpUnmarshalerStartBatch(dpum);

	  //
	  OZ_Term utRet = dpUnmarshalTerm(bb, dpum);

	  //
	  switch (utRet) {
	  case (OZ_Term) 0:
	    dpUnmarshalerFinishBatch(dpum);
	    messageError(mt, "MsgContainer::unmarshal: bad Oz term");
	    return (FALSE);

	  case (OZ_Term) -1:
	    this->transController = transController;
	    msgFields[i].ft = FT_TERMCONT;
	    cont = (void *) dpum;
	    setFlag(MSG_HAS_UNMARSHALCONT);
	    return (TRUE);	// OK but not yet done;

	  default:
	    dpUnmarshalerFinishBatch(dpum);
	    msgFields[i].arg = (void *) utRet;
	    msgFields[i].ft = FT_NONE;
	    transController->returnUnmarshaler(dpum);
	    cont = (void *) 0;
	    continue;
	  }
	}
	Assert(0);

      case FT_TERMCONT:
	{
	  Assert(cont != (void *) 0);
	  Assert(checkFlag(MSG_HAS_UNMARSHALCONT));
	  Builder *dpum = (Builder *) cont;

	  //
	  OZ_Term utRet = dpUnmarshalTerm(bb, dpum);

	  //
	  switch (utRet) {
	  case (OZ_Term) 0:
	    dpUnmarshalerFinishBatch(dpum);
	    messageError(mt, "MsgContainer::unmarshal: bad Oz term");
	    return (FALSE);

	  case (OZ_Term) -1:
	    return (TRUE);	// still not yet done;

	  default:
	    dpUnmarshalerFinishBatch(dpum);
	    msgFields[i].arg = (void *) utRet;
	    msgFields[i].ft = FT_NONE;
	    transController->returnUnmarshaler(dpum);
	    cont = (void *) 0;
	    continue;
	  }
	}
	Assert(0);

      case FT_STRING:
        msgFields[i].arg = (void *) unmarshalString(bb);
	msgFields[i].ft = FT_NONE;
	continue;

      case FT_SITE:
	msgFields[i].arg = (void *) unmarshalDSite(bb);
	msgFields[i].ft = FT_NONE;
	continue;

      case FT_NONE:
	continue;		// nothing is expected;

      default:
	OZ_error("unexpected tag in MsgContainer::unmarshal()");
      }

      // We bail out of the case statement iff we have a suspension,
      // otherwise do 'continue' directly:
      Assert(0);
    }
  }

  // all elements are finished;
  clearFlag(MSG_HAS_UNMARSHALCONT);
  return (TRUE);
}

undefine(`argEnc')
undefine(`message')

define(mcarg,`ifelse($1,Index,Ext_OB_TIndex &ind,
                   $1,Term,TaggedRef &t,
                   $1,FullTopTerm,TaggedRef &t,
		   $1,String,char *&str,
                   $1,Credit,int &c,
                   $1,Site,DSite *&s1,
	           $1,Site2,DSite *&s2,
	           $1,Int,int &int1,
	           $1,Int2,int &int2)'
            `ifelse($2,`',`',`,')')

define(argEnc,`ifelse($1,Index,ind=(Ext_OB_TIndex),
	              $1,Term,t=(TaggedRef),
	              $1,FullTopTerm,t=(TaggedRef),
	              $1,Credit,c=(int),
	              $1,String,str=(char*),
                      $1,Site,s1=(DSite*),
                      $1,Site2,s2=(DSite*),
		      $1,Int,int1=(int),
		      $1,Int2,int2=(int),
                      //)')

define(message,`
       void MsgContainer::get_$1(mcarg($2,$3) mcarg($3,$4) mcarg($4,$5) mcarg($5,$6) mcarg($6,$7)) {
         argEnc($2) msgFields[0].arg;
         argEnc($3) msgFields[1].arg;
         argEnc($4) msgFields[2].arg;
         argEnc($5) msgFields[3].arg;
         argEnc($6) msgFields[4].arg;
       }')

include(EMUDIR/msgFormat.m4)

undefine(`message')
undefine(`argEnc')

define(message,`
       case $1: {
         argEnc($2,msgFields[0].arg,msgFields[0].ft)
         argEnc($3,msgFields[1].arg,msgFields[1].ft)
         argEnc($4,msgFields[2].arg,msgFields[2].ft)
         argEnc($5,msgFields[3].arg,msgFields[3].ft)
         argEnc($6,msgFields[4].arg,msgFields[4].ft)
         break;
       }')

define(argEnc,`ifelse($1,Index,,
	              $1,Term,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
			         oz_gCollectTerm((TaggedRef &) $2, 
			                         (TaggedRef &) $2);,
	              $1,FullTopTerm,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
                                 oz_gCollectTerm((TaggedRef &) $2, (TaggedRef &) $2);,
	              $1,int,,
	              $1,String,,
                      $1,Site,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
((DSite*) $2)->makeGCMarkSite();,
                      $1,Site2,if(!checkFlag(MSG_HAS_UNMARSHALCONT) || $3==FT_NONE)
((DSite*) $2)->makeGCMarkSite();,
		      $1,Int,,
		      $1,Int2,,)')

void MsgContainer::gcMsgC()
{
//     printf("GC of %x (ucont %d term %x)\n",this,
//             checkFlag(MSG_HAS_UNMARSHALCONT),
//    	 (msgFields[1]).arg);
  if(cntrlVar)
    oz_gCollectTerm(cntrlVar,cntrlVar);
  if(destination!=NULL) 
    destination->makeGCMarkSite();
  if (checkFlag(MSG_HAS_MARSHALCONT) && cont != 0) {
    ((DPMarshaler *) cont)->gCollect();
  } else if(checkFlag(MSG_HAS_UNMARSHALCONT) && cont != 0){
    ((Builder *) cont)->gCollect();
  }

  //
  switch(mt) {
include(EMUDIR/msgFormat.m4)
  default:
    PD((TCP_INTERFACE,"marshal got unknown `message': %d",mt));
  }
}

//
void MsgContainer::gcStart()
{
  if (checkFlag(MSG_HAS_MARSHALCONT) && cont != 0)
    ((DPMarshaler *) cont)->gcStart();
}

void MsgContainer::gcFinish()
{
  if (checkFlag(MSG_HAS_MARSHALCONT) && cont != 0)
    ((DPMarshaler *) cont)->gcFinish();
}

undefine(`message')
undefine(`argEnc')

define(message,`
       case $1:
       msgFields[0].ft=argEnc($2);
       msgFields[1].ft=argEnc($3);
       msgFields[2].ft=argEnc($4);
       msgFields[3].ft=argEnc($5);
       msgFields[4].ft=argEnc($6);
       break;')


define(argEnc,`ifelse($1,Index,FT_NUMBER,
	              $1,Term,FT_TERM,
	              $1,FullTopTerm,FT_FULLTOPTERM,
	              $1,Credit,FT_CREDIT,
	              $1,String,FT_STRING,
                      $1,Site,FT_SITE,
                      $1,Site2,FT_SITE,
		      $1,Int,FT_NUMBER,
		      $1,Int2,FT_NUMBER,
		      FT_NONE)')

void MsgContainer::resetMarshaling() {
  if(checkFlag(MSG_HAS_MARSHALCONT)) {
    clearFlag(MSG_HAS_MARSHALCONT);
    if(cont!=0) {
      transController->returnMarshaler((DPMarshaler *) cont);
      cont=0;
    }
  }

  // Reset fields
  switch(mt) {
    include(EMUDIR/msgFormat.m4)
  default:
    ;
  }
}

// m4 -E -B10000 -DEMUDIR=/home/annan/source/mozart/platform/emulator/libdp msgContainer_marshal.m4cc > msgContainer_marshal.cc

